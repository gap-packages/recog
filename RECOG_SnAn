# SnAnUnknownDegree

This file describes details of the `SnAnUnknownDegree` implementation in `recog`. The algorithm is based on the paper `[JLNP13]`.

## General Strategy
Here we describe the general strategy that is used to recognise if a group is ismorphic to `An` or `Sn` for `n >= 7`.

We have to be careful what we do for small degrees.
If we pass an `A5`, `S5`, `A6`, `S6` into `SnAnUnknownDegree`, then it will not recognize it.
If the input acts on a space with a large dimension, then this can take forever.

- We assume that our input group `G` is a projective irreducible matrix group.
- Deduce an upper bound `N` for the degree of `An`, `Sn`.
- Look at some orders and deduce a lower bound `M` for the degree.
    - If `M > N`, then we excluded `An`, `Sn`.
    - If `M <= 6`, then we return `TemporaryFailure`.
    - If `N > 20`, use Magma Code `GuessSnAnDegree` to guess the degree by element orders.
    - Otherwise, we continue.
- Now we can assume for the degree `n >= 7`. We need to ensure this, since `SnAnUnknownDegree` cannot recognise `A5`, `S5`, `A6`, `S6`
  and could run for a considerable time.
- Monte-Carlo: Try to compute standard generators and degree `n` of largest `An < G` via the algorithm in `[JLNP13]`.
- Try to compute an isomorphism from `G` to `An` or `Sn`.
    - If `n < 11`, then use methods from Conder
    - Otherwise, we have `n >= 11` and use methods from `SnAnKnownDegree` in `[BLGN+03]`

## Changes
Here we collect the changes in `SnAnUnknownDegree` compared to the "vanilla" implementation of the algorithm according to the paper `[JLNP13]`.

- Computation of upper bound `N` done as in `[L84]` and `[KL90]`.
- Computation of lower bound `M` by element orders.
- For each ThreeCycleCandidate `c` we check if `c^3 = 1` and we check for some random elements `r` if for the element `x := c * c^r` either `x^5 = 1` or `x^6 = 1` holds (The element `x` needs to have order `1`, `2`, `3` or `5`).
- Use `RecogniseSnAnLazy` that caches iterators constructed by `ThreeCycleCandidatesIterator` and returns `TemporaryFailure` more quickly.
- `ThreeCycleCandidatesIterator` uses a similar approach to that from the Magma Code `GetNextThreeCycle` and thus computes the elements in a different ordering.
  - We work in batches of at most `L = 10` involutions in a linear manner. We save all involutions considered so far.
  - For every involution, we consider only up to `K = 5` random conjugates. If none is successful, we move to the next involution. We save all involutions considered so far.
  - If a batch of involutions reaches the last involution, i.e. the `B`-th one, we start with the first involution in the next round.
  - After a batch of involutions was completely processed, we return `SnAnTryLater` and exit the recognition method in the lazy variant.
  - However, as in the vanilla implementation, we return `TemporaryFailure` if for all `B` involutions
  either `C` conjugates have been tested in total or `T` conjugates were proven to commutate with the involution.
- Use Conder's Thesis to compute images for degree `n <= 10`.
