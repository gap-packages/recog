#############################################################################
##
##  This file is part of recog, a package for the GAP computer algebra system
##  which provides a collection of methods for the constructive recognition
##  of groups.
##
##  This files's authors include Daniel Rademacher.
##
##  Copyright of recog belongs to its developers whose names are too numerous
##  to list here. Please refer to the COPYRIGHT file for details.
##
##  SPDX-License-Identifier: GPL-3.0-or-later
##
#############################################################################



#############################################################################
#############################################################################
######## Main function for symplectic groups ################################
#############################################################################
#############################################################################


RECOG.FindStdGens_Sp := function(sld)

    return RECOG.FindStdGens_Sp2(sld,DimensionOfMatrixGroup(sld));

end;


RECOG.FindStdGens_Sp2 := function(sld,IsoDim)

    # Group generated by input must be isomorphic Sp(IsoDim,q)

    # gens of sld must be gens for Sp(d,q) in its natural rep with memory
    # This function calls RECOG.Spn_constructsp4 and then extends
    # the basis to a basis of the full row space and calls
    # RECOG.Spn_UpStep often enough. Finally it returns an slp such
    # that the Sp(d,q) standard generators with respect to this basis are
    # expressed by the slp in terms of the original generators of sld.
    local V,b,bas,basi,basit,d,data,ext,fakegens,id,nu,nu2,p,q,resl2,sl2,sp4gens,bigcorrection,
        sl2gensf,sl2genss,sp4stdf,slp,slpsl2std,slptosl2,st,std,stdgens,i,ex,f,form,smallsp4,basechange,myslp,sp8gens,sp8,WrongForm,correctForm1,correctForm2;

    # Some setup:
    f := FieldOfMatrixGroup(sld);
    p := Characteristic(f);
    if IsEvenInt(p) then
        Display("Since the characteristic is even, we have to call the algorithm for Omega(0,d+1,q) at this point. But this is not supported yet.");
        return fail;
    fi;
    q := Size(f);
    ext := DegreeOverPrimeField(f);
    d := DimensionOfMatrixGroup(sld);
    form := RECOG.SymplecticForm(sld);
    if not(IsObjWithMemory(GeneratorsOfGroup(sld)[1])) then
        sld := GroupWithMemory(sld);
    fi;

    # First find an Sp4 with the space it acts on;
    Info(InfoRecog,2,"Finding an Sp4...");
    Info(InfoRecog,2,"-----");
    Info(InfoRecog,2,"Start of the GoingDown Algorithm.");
    data := RECOG.Spn_constructsp4(sld,d,q,form);
    if data = fail then
        return TemporaryFailure;
    fi;
    Info(InfoRecog,2,"The GoingDown Algorithm was successful.");
    Info(InfoRecog,2,"-----");

    myslp := data[4];

    smallsp4 := RECOG.ExtractSmallerGroup(GeneratorsOfGroup(data[1]),IdentityMat(d,GF(q)),4);
    Info(InfoRecog,2,"Start of constructive recognition of Sp(4,q)");
    i := 1;
    sp4gens := fail;
    while i < 10 and sp4gens = fail do
        if not(IsEvenInt(q)) then
            sp4gens := RECOG.FindStdGensSp4(smallsp4[1],d,q);
        else
            sp8 := RECOG.ExtractSmallerGroup(GeneratorsOfGroup(data[1]),data[2],8)[1];
            WrongForm := PreservedSesquilinearForms(sp8)[1];
            correctForm1 := BaseChangeToCanonical(WrongForm);
            correctForm2 := BaseChangeToCanonical(PreservedSesquilinearForms(Sp(8,q))[1]);
            sp8 := sp8^(correctForm1^(-1)*correctForm2);
            bigcorrection := IdentityMat(d,GF(q));
            bigcorrection{[1..8]}{[1..8]} := (correctForm2)^(-1)*correctForm1;
            basechange := bigcorrection*data[2];
            stdgens := RECOG.MakeSp_StdGens(p,ext,8,8).all;
            sp8gens := RECOG.FindStdGensUsingBSGS(sp8,stdgens,false,false);
            #if Size(sp8) <> 197406720 and 174182400 <> Size(sp8) then
                Error("here");
            #fi;
            return "TODO";
        fi;
        i := i +1;
    od;
    if sp4gens = fail then
        Info(InfoRecog,2,"-----");
        Info(InfoRecog,2,"Constructive recognition of Sp(4,q) failed. Restart.");
        Info(InfoRecog,2,"-----");
        return TemporaryFailure;
    fi;
    basechange := sp4gens[2]*data[2];
    myslp := CompositionOfStraightLinePrograms(sp4gens[3],myslp);
    Info(InfoRecog,2,"Constructive recognition of Sp(4,q) was successful.");
    Info(InfoRecog,2,"-----");

    fakegens := ListWithIdenticalEntries(Length(GeneratorsOfGroup(sld)), ());
    fakegens := GeneratorsWithMemory(fakegens);
    sp4stdf := ResultOfStraightLineProgram(myslp,fakegens);
    std := rec( f := f, d := d, GoalDim := IsoDim, n := 4, bas := basechange, basi := basechange^(-1),
                sld := sld, sldf := fakegens, spnstdf := sp4stdf,
                p := p, ext := ext );
    Info(InfoRecog,2,"Going up to Sp_d again...");
    Info(InfoRecog,2,"-----");
    Info(InfoRecog,2,"Start of the GoingUp Algorithm");
    while std.n < std.GoalDim do
        RECOG.Spn_UpStep(std);
    od;
    Info(InfoRecog,2,"The GoingUp Algorithm was successful.");
    Info(InfoRecog,2,"-----");
    return rec( slpstd := SLPOfElms(std.spnstdf),
                bas := std.bas, basi := std.basi );
end;
