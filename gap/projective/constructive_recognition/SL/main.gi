#############################################################################
##
##  This file is part of recog, a package for the GAP computer algebra system
##  which provides a collection of methods for the constructive recognition
##  of groups.
##
##  This files's authors include Daniel Rademacher.
##
##  Copyright of recog belongs to its developers whose names are too numerous
##  to list here. Please refer to the COPYRIGHT file for details.
##
##  SPDX-License-Identifier: GPL-3.0-or-later
##
#############################################################################



#############################################################################
#############################################################################
######## Main function for special linear groups ############################
#############################################################################
#############################################################################



RECOG.FindStdGens_SL := function(sld)

    # Group generated by input must be isomorphic SL(d,q)

    # gens of sld must be gens for SL(d,q) in its natural rep with memory
    # This function calls RECOG.SLn_constructsl2 and then extends
    # the basis to a basis of the full row space and calls
    # RECOG.SLn_UpStep often enough. Finally it returns an slp such
    # that the SL(d,q) standard generators with respect to this basis are
    # expressed by the slp in terms of the original generators of sld.
    local V,b,bas,basi,basit,d,data,ext,fakegens,id,nu,nu2,p,q,resl2,sl2,sl2gens,
        sl2gensf,sl2genss,sl2stdf,slp,slpsl2std,slptosl2,st,std,stdgens,i,ex,f;

    # Some setup:
    f := FieldOfMatrixGroup(sld);
    p := Characteristic(f);
    q := Size(f);
    ext := DegreeOverPrimeField(f);
    d := DimensionOfMatrixGroup(sld);
    if not(IsObjWithMemory(GeneratorsOfGroup(sld)[1])) then
        sld := GroupWithMemory(sld);
    fi;

    # First find an SL2 with the space it acts on;
    Info(InfoRecog,2,"Finding an SL2...");
    Info(InfoRecog,2,"-----");
    Info(InfoRecog,2,"Start of the GoingDown Algorithm.");
    data := RECOG.SLn_constructsl2(sld,d,q);
    Info(InfoRecog,2,"The GoingDown Algorithm was successful.");
    Info(InfoRecog,2,"-----");

    bas := ShallowCopy(BasisVectors(Basis(data[2])));
    sl2 := data[1];
    slptosl2 := SLPOfElms(GeneratorsOfGroup(sl2));
    sl2gens := StripMemory(GeneratorsOfGroup(sl2));
    V := data[2];
    b := Basis(V,bas);
    sl2genss := List(sl2gens,x->RECOG.LinearAction(b,f,x));

    Info(InfoRecog,2,"-----");
    Info(InfoRecog,2,"Solving the base case");
    if q in [2,3,4,5,9] then
        Info(InfoRecog,2,"In fact found an SL4...");
        stdgens := RECOG.MakeSL_StdGens(p,ext,4,4).all;
        slpsl2std := RECOG.FindStdGensUsingBSGS(Group(sl2genss),stdgens,
                                                false,false);
        nu := List(sl2gens,x->RECOG.FixspaceMat(x));
        ex := SumIntersectionMat(nu[1],nu[2])[2];
        for i in [3..Length(nu)] do
            ex := SumIntersectionMat(nu[3],ex);
        od;
        Append(bas,ex);
        ConvertToMatrixRep(bas,q);
        basi := bas^-1;
    else
        # Now compute the natural SL2 action and run constructive recognition:
        Info(InfoRecog,2,
            "Recognising this SL2 constructively in 2 dimensions...");
        sl2genss := GeneratorsWithMemory(sl2genss);
        if IsEvenInt(q) then
            resl2 := RECOG.RecogniseSL2NaturalEvenChar(Group(sl2genss),f,false);
        else
            resl2 := RECOG.RecogniseSL2NaturalOddCharUsingBSGS(Group(sl2genss),f);
        fi;
        slpsl2std := SLPOfElms(resl2.all);
        bas := resl2.bas * bas;
        # We need the actual transvections:
        slp := SLPOfElms([resl2.s[1],resl2.t[1]]);
        st := ResultOfStraightLineProgram(slp,
                                        StripMemory(GeneratorsOfGroup(sl2)));

        # Extend basis by something invariant under SL2:
        id := IdentityMat(d,f);
        nu := NullspaceMat(StripMemory(st[1]-id));
        nu2 := NullspaceMat(StripMemory(st[2]-id));
        Append(bas,SumIntersectionMat(nu,nu2)[2]);
        ConvertToMatrixRep(bas,q);
        basi := bas^-1;
    fi;
    Info(InfoRecog,2,"Finished the base case.");
    Info(InfoRecog,2,"-----");

    # Now set up fake generators for keeping track what we do:
    fakegens := ListWithIdenticalEntries(Length(GeneratorsOfGroup(sld)),());
    fakegens := GeneratorsWithMemory(fakegens);
    sl2gensf := ResultOfStraightLineProgram(slptosl2,fakegens);
    sl2stdf := ResultOfStraightLineProgram(slpsl2std,sl2gensf);
    std := rec( f := f, d := d, n := 2, bas := bas, basi := basi,
                sld := sld, sldf := fakegens, slnstdf := sl2stdf,
                p := p, ext := ext );
    Info(InfoRecog,2,"Going up to SL_d again...");
    Info(InfoRecog,2,"-----");
    Info(InfoRecog,2,"Start of the GoingUp Algorithm");
    while std.n < std.d do
        RECOG.SLn_UpStep(std);
    od;
    Info(InfoRecog,2,"The GoingUp Algorithm was successful.");
    Info(InfoRecog,2,"-----");
    return rec( slpstd := SLPOfElms(std.slnstdf),
                bas := std.bas, basi := std.basi );
end;



RECOG.FindStdGensSmallerMatrices_SL := function(sld)

    # Group generated by input must be isomorphic SL(d,q)
    
    # gens of sld must be gens for SL(d,q) in its natural rep with memory
    # This function calls RECOG.SLn_constructsl2 and then extends
    # the basis to a basis of the full row space and calls
    # RECOG.SLn_UpStep often enough. Finally it returns an slp such
    # that the SL(d,q) standard generators with respect to this basis are
    # expressed by the slp in terms of the original generators of sld.
    local V,b,bas,basi,basit,d,data,ext,fakegens,id,nu,nu2,p,q,resl2,sl2,sl2gens,
        sl2gensf,sl2genss,sl2stdf,slp,slpsl2std,slptosl2,st,std,stdgens,i,ex,f;

    # Some setup:
    f := FieldOfMatrixGroup(sld);
    p := Characteristic(f);
    q := Size(f);
    ext := DegreeOverPrimeField(f);
    d := DimensionOfMatrixGroup(sld);
    if not(IsObjWithMemory(GeneratorsOfGroup(sld)[1])) then
        sld := GroupWithMemory(sld);
        #### Added by DR! Optimize this line!
        ### second argument for length of list, third argument for number of shuffles
        Group_InitPseudoRandom(sld,Size(GeneratorsOfGroup(sld))+2,5);
        # Noch weniger initialisierungen testen
        # TODO: Wenn initialisiert, nicht nochmal, if hinzufÃ¼gen
    fi;

    # First find an SL2 with the space it acts on;
    Info(InfoRecog,2,"Finding an SL2...");
    Info(InfoRecog,2,"-----");
    Info(InfoRecog,2,"Start of the GoingDown Algorithm.");
    data := RECOG.SLn_constructsl2WithSmallerMatrices(sld,d,q);
    Info(InfoRecog,2,"The GoingDown Algorithm was successful.");
    Info(InfoRecog,2,"-----");

    bas := ShallowCopy(data[2]);
    sl2 := data[1];
    slptosl2 := data[3];
    sl2gens := StripMemory(GeneratorsOfGroup(sl2));
    b := Basis(VectorSpace(GF(q),bas),bas);
    sl2genss := data[4];

    Info(InfoRecog,2,"-----");
    Info(InfoRecog,2,"Solving the base case");
    if q in [2,3,4,5,9] then
        Info(InfoRecog,2,"In fact found an SL4...");
        stdgens := RECOG.MakeSL_StdGens(p,ext,4,4).all;
        slpsl2std := RECOG.FindStdGensUsingBSGS(Group(sl2genss),stdgens,
                                                false,false);
        Append(bas,data[5]);
        ConvertToMatrixRep(bas,q);
        basi := bas^-1;
    else
        # Now compute the natural SL2 action and run constructive recognition:
        Info(InfoRecog,2,
            "Recognising this SL2 constructively in 2 dimensions...");
        sl2genss := GeneratorsWithMemory(sl2genss);
        if IsEvenInt(q) then
            resl2 := RECOG.RecogniseSL2NaturalEvenChar(Group(sl2genss),f,false);
        else
            resl2 := RECOG.RecogniseSL2NaturalOddCharUsingBSGS(Group(sl2genss),f);
        fi;
        slpsl2std := SLPOfElms(resl2.all);
        if resl2.bas <> [[1,0],[0,1]]*One(f) then
        Error("So i have to deal with this case...");
        # RECOG.FindStdGensSmallerMatrices_SL(SL(200,2^6),200); gives an example for this case. So we have
        # to add at least one more base change
        else
        #bas := resl2.bas * bas;
        # We need the actual transvections:
        slp := SLPOfElms([resl2.s[1],resl2.t[1]]);
        Append(bas,data[5]);
        ConvertToMatrixRep(bas,q);
        basi := bas^-1;
        fi;
    fi;
    Info(InfoRecog,2,"Finished the base case.");
    Info(InfoRecog,2,"-----");

    # Now set up fake generators for keeping track what we do:
    fakegens := ListWithIdenticalEntries(Length(GeneratorsOfGroup(sld)),());
    fakegens := GeneratorsWithMemory(fakegens);
    sl2gensf := ResultOfStraightLineProgram(slptosl2,fakegens);
    sl2stdf := ResultOfStraightLineProgram(slpsl2std,sl2gensf);
    std := rec( f := f, d := d, n := 2, bas := bas, basi := basi,
                sld := sld, sldf := fakegens, slnstdf := sl2stdf,
                p := p, ext := ext );
    Info(InfoRecog,2,"Going up to SL_d again...");
    Info(InfoRecog,2,"-----");
    Info(InfoRecog,2,"Start of the GoingUp Algorithm");
    while std.n < std.d do
        RECOG.SLn_UpStep(std);
    od;
    Info(InfoRecog,2,"The GoingUp Algorithm was successful.");
    Info(InfoRecog,2,"-----");
    return rec( slpstd := SLPOfElms(std.slnstdf),
                bas := std.bas, basi := std.basi );
end;
