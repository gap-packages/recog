#############################################################################
##
##  This file is part of recog, a package for the GAP computer algebra system
##  which provides a collection of methods for the constructive recognition
##  of groups.
##
##  This files's authors include Daniel Rademacher.
##
##  Copyright of recog belongs to its developers whose names are too numerous
##  to list here. Please refer to the COPYRIGHT file for details.
##
##  SPDX-License-Identifier: GPL-3.0-or-later
##
#############################################################################



#############################################################################
#############################################################################
######## Main function for unitary groups ###################################
#############################################################################
#############################################################################



RECOG.FindStdGens_SU := function(sld)

    return RECOG.FindStdGens_SUTest(sld,DimensionOfMatrixGroup(sld));

end;



RECOG.FindStdGens_SU2 := function(sld,IsoDim)

# Group generated by input must be isomorphic SU(IsoDim,q)

# gens of sld must be gens for Sp(d,q) in its natural rep with memory
# This function calls RECOG.SLn_constructsl2 and then extends
# the basis to a basis of the full row space and calls
# RECOG.SLn_UpStep often enough. Finally it returns an slp such
# that the Sp(d,q) standard generators with respect to this basis are
# expressed by the slp in terms of the original generators of sld.
local V,b,bas,basi,basit,d,data,ext,fakegens,id,nu,nu2,p,q,resl2,su2,su2small,su2gens,su2genssmall,su2completegens,
    sl2gensf,sl2genss,sl2stdf,slp,slpsl2std,slptosl2,st,std,stdgens,i,ex,f,form;

    # Some setup:
    f := FieldOfMatrixGroup(sld);
    p := Characteristic(f);
    q := Size(f);
    ext := DegreeOverPrimeField(f);
    d := DimensionOfMatrixGroup(sld);
    form := PreservedForms(sld)[1];
    form := form!.matrix;
    if not(IsObjWithMemory(GeneratorsOfGroup(sld)[1])) then
        sld := GroupWithMemory(sld);
    fi;

    # First find an SU2 with the space it acts on;
    Info(InfoRecog,2,"Finding an SU2...");
    Info(InfoRecog,2,"-----");
    Info(InfoRecog,2,"Start of the GoingDown Algorithm.");
    data := RECOG.SUn_constructsu2(sld,d,q,form);
    Info(InfoRecog,2,"The GoingDown Algorithm was successful.");
    Info(InfoRecog,2,"-----");

    #bas := ShallowCopy(BasisVectors(Basis(data[2])));
    su2 := data[1];
    su2small := RECOG.ExtractSmallerGroup(GeneratorsOfGroup(su2),IdentityMat(20,GF(q)),2)[1];
    #slptosl2 := SLPOfElms(GeneratorsOfGroup(sl2));
    #sl2gens := StripMemory(GeneratorsOfGroup(sl2));
    #V := data[2];
    #b := Basis(V,bas);
    #sl2genss := List(sl2gens,x->RECOG.LinearAction(b,f,x));

    Info(InfoRecog,2,"-----");
    Info(InfoRecog,2,"Solving the base case");
    su2genssmall := RECOG.ConstructiveRecognitionSL2NaturalRepresentation(su2small,Sqrt(q),0.001);
    su2gens := RECOG.LiftGroup(su2genssmall[1],2,q,d)[2];
    #su2completegens := RECOG.ConstructiveRecognitionSL2NaturalRepresentationCompleteBasis(su2gens[1],GF(Sqrt(q)),Sqrt(q),p,Size(Factors(q))/2);
    return [su2gens,RECOG.LiftGroup([su2genssmall[2]],2,q,d)[2,1]*data[2]];
    #if q in [2,3,4,5,9] then
    #    Info(InfoRecog,2,"In fact found an SL4...");
    #    stdgens := RECOG.MakeSL_StdGens(p,ext,4,4).all;
    #    slpsl2std := RECOG.FindStdGensUsingBSGS(Group(sl2genss),stdgens,
    #                                            false,false);
    #    nu := List(sl2gens,x->RECOG.FixspaceMat(x));
    #    ex := SumIntersectionMat(nu[1],nu[2])[2];
    #    for i in [3..Length(nu)] do
    #        ex := SumIntersectionMat(nu[3],ex);
    #    od;
    #    Append(bas,ex);
    #    ConvertToMatrixRep(bas,q);
    #    basi := bas^-1;
    #else
    #    # Now compute the natural SL2 action and run constructive recognition:
    #    Info(InfoRecog,2,
    #         "Recognising this SL2 constructively in 2 dimensions...");
    #    sl2genss := GeneratorsWithMemory(sl2genss);
    #    if IsEvenInt(q) then
    #        resl2 := RECOG.RecogniseSL2NaturalEvenChar(Group(sl2genss),f,false);
    #    else
    #        resl2 := RECOG.RecogniseSL2NaturalOddCharUsingBSGS(Group(sl2genss),f);
    #    fi;
    #    slpsl2std := SLPOfElms(resl2.all);
    #    bas := resl2.bas * bas;
    #    # We need the actual transvections:
    #    slp := SLPOfElms([resl2.s[1],resl2.t[1]]);
    #    st := ResultOfStraightLineProgram(slp,
    #                                      StripMemory(GeneratorsOfGroup(sl2)));
    #
    #    # Extend basis by something invariant under SL2:
    #    id := IdentityMat(d,f);
    #    nu := NullspaceMat(StripMemory(st[1]-id));
    #    nu2 := NullspaceMat(StripMemory(st[2]-id));
    #    Append(bas,SumIntersectionMat(nu,nu2)[2]);
    #    ConvertToMatrixRep(bas,q);
    #    basi := bas^-1;
    #fi;
    #Display("Finished the base case.");
    #Display("-----");

    # Now set up fake generators for keeping track what we do:
    #fakegens := ListWithIdenticalEntries(Length(GeneratorsOfGroup(sld)),());
    #fakegens := GeneratorsWithMemory(fakegens);
    #sl2gensf := ResultOfStraightLineProgram(slptosl2,fakegens);
    #sl2stdf := ResultOfStraightLineProgram(slpsl2std,sl2gensf);
    #std := rec( f := f, d := d, GoalDim := IsoDim, n := 2, bas := bas, basi := basi,
    #            sld := sld, sldf := fakegens, slnstdf := sl2stdf,
    #            p := p, ext := ext );
    #Info(InfoRecog,2,"Going up to SL_d again...");
    #Display("-----");
    #Display("Start of the GoingUp Algorithm");
    #while std.n < std.GoalDim do
    #    RECOG.SLn_UpStep(std);
    #od;
    #Display("The GoingUp Algorithm was successful.");
    #Display("-----");
    #return rec( slpstd := SLPOfElms(std.slnstdf),
    #            bas := std.bas, basi := std.basi );

    return "Hallo";
end;












# TODO: Next function is actually the correct function!


RECOG.FindStdGens_SUTest := function(sld,IsoDim)

# Group generated by input must be isomorphic SU(IsoDim,q)

# gens of sld must be gens for Sp(d,q) in its natural rep with memory
# This function calls RECOG.SLn_constructsl2 and then extends
# the basis to a basis of the full row space and calls
# RECOG.SLn_UpStep often enough. Finally it returns an slp such
# that the Sp(d,q) standard generators with respect to this basis are
# expressed by the slp in terms of the original generators of sld.
local V,b,bas,basi,basit,d,data,ext,fakegens,id,nu,nu2,p,q,resl2,su2,su2small,su2gens,su2genssmall,su2completegens,slpsu4std,myslp,su4stdf,
    sl2gensf,sl2genss,sl2stdf,slp,slpsl2std,slptosl2,st,std,stdgens,i,ex,f,form,WrongForm,ChangeToCorrectFormBig,ChangeToCorrectFormBig2,
    Galois,phi,alpha,primitive,finishedslp;

    # Some setup:
    f := FieldOfMatrixGroup(sld);
    p := Characteristic(f);
    q := Size(f);
    ext := DegreeOverPrimeField(f);
    d := DimensionOfMatrixGroup(sld);
    form := PreservedForms(sld)[1];
    form := form!.matrix;
    if not(IsObjWithMemory(GeneratorsOfGroup(sld)[1])) then
        sld := GroupWithMemory(sld);
    fi;

    Galois := GaloisGroup(f);
    Galois := Filtered(Galois, x -> Order(x) = 2);
    phi := Galois[1];

    # First find an SU2 with the space it acts on;
    Info(InfoRecog,2,"Finding an SU2...");
    Info(InfoRecog,2,"-----");
    Info(InfoRecog,2,"Start of the GoingDown Algorithm.");
    data := RECOG.SUn_constructsu4(sld,d,q,form);
    if data = fail then
        return TemporaryFailure;
    fi;
    Info(InfoRecog,2,"The GoingDown Algorithm was successful.");
    Info(InfoRecog,2,"-----");

    myslp := data[4];

    su2 := data[1];
    su2small := RECOG.ExtractSmallerGroup(GeneratorsOfGroup(su2),IdentityMat(20,GF(q)),4)[1];

    Info(InfoRecog,2,"-----");
    Info(InfoRecog,2,"Solving the base case");
    bas := data[2];

    WrongForm := PreservedSesquilinearForms(su2small)[1];
    ChangeToCorrectFormBig := IdentityMat(d,f);
    ChangeToCorrectFormBig{[1..4]}{[1..4]} := BaseChangeToCanonical(WrongForm)^(-1);
    WrongForm := HermitianFormByMatrix(PermutationMat((1,4)(2,3),4,GF(q)),f);
    ChangeToCorrectFormBig2 := IdentityMat(d,f);
    ChangeToCorrectFormBig2{[1..4]}{[1..4]} := BaseChangeToCanonical(WrongForm);
    su2 := su2^(ChangeToCorrectFormBig*ChangeToCorrectFormBig2);
    su2small := RECOG.ExtractSmallerGroup(GeneratorsOfGroup(su2),IdentityMat(20,f),4)[1];
    bas := (ChangeToCorrectFormBig*ChangeToCorrectFormBig2)^(-1)*bas;
    basi := bas^(-1);

    stdgens := RECOG.MakeSU_StdGens(4,Sqrt(q),p,ext,phi);
    alpha := stdgens.alpha;
    stdgens := stdgens.all;

    slpsu4std := RECOG.FindStdGensUsingBSGS(su2small,stdgens,
                                                false,false);

    myslp := CompositionOfStraightLinePrograms(slpsu4std,myslp);

    #return [su2,bas,myslp];

    Info(InfoRecog,2,"Constructive recognition of SU(4,q) was successful.");
    Info(InfoRecog,2,"-----");

    # Now set up fake generators for keeping track what we do:
    fakegens := ListWithIdenticalEntries(Length(GeneratorsOfGroup(sld)),());
    fakegens := GeneratorsWithMemory(fakegens);
    su4stdf := ResultOfStraightLineProgram(myslp,fakegens);
    std := rec( f := f, d := d, GoalDim := IsoDim, n := 4, bas := bas, basi := basi,
                sld := sld, sldf := fakegens, sunstdf := su4stdf,
                p := p, ext := ext, phi := phi, alpha := alpha );
    Info(InfoRecog,2,"Going up to Sp_d again...");
    Info(InfoRecog,2,"-----");
    Info(InfoRecog,2,"Start of the GoingUp Algorithm");
    while std.n < std.GoalDim do
        RECOG.SUn_UpStepWithSLP(std);
    od;
    Info(InfoRecog,2,"The GoingUp Algorithm was successful.");
    Info(InfoRecog,2,"-----");
    if IsEvenInt(IsoDim) then
        return rec( slpstd := SLPOfElms(std.sunstdf),
                    bas := std.bas, basi := std.basi );
    else
        finishedslp := std.sunstdf;
        Add(std.sunstdf,std.myx);
        return rec( slpstd := SLPOfElms(finishedslp),
                    bas := std.bas, basi := std.basi );
    fi;
end;



RECOG.MakeSU_StdGensTODO := function(p,ext,n,d)
  local a,b,f,i,q,s,t,x,res;
  f := GF(p,ext);
  q := Size(f);
  a := IdentityMat(d,f);
  a := a{Concatenation([n],[1..n-1],[n+1..d])};
  ConvertToMatrixRep(a,q);
  b := IdentityMat(d,f);
  b := b{Concatenation([1,n],[2..n-1],[n+1..d])};
  ConvertToMatrixRep(b,q);
  if IsEvenInt(n) then
      a[1] := -a[1];
  else
      b[2] := -b[2];
  fi;
  s := [];
  t := [];
  for i in [0..ext-1] do
      x := IdentityMat(d,f);
      x[1,2] := Z(p,ext)^i;
      Add(s,x);
      x := IdentityMat(d,f);
      x[2,1] := Z(p,ext)^i;
      Add(t,x);
  od;

 

  res := rec( s := s, t := t, a := a, b := b, f := f, q := q, p := p,
              ext := ext, One := IdentityMat(d,f), one := One(f),
              d := d );
  res.all := Concatenation( res.s, res.t, [res.a], [res.b] );
  return res;
end;



RECOG.MakeSU_StdGens := function( d, q, p, ext, phi )

    local w, alpha, s, t, delta, u, v, x, y, J, fld, res, upper, lower, backdiagonal, ele, i, f;

    f := GF(q);
    w := PrimitiveElement(GF(q^2));
    alpha := w^((q+1)/2);
    fld := GF(q^2);

    s := IdentityMat( d, fld );
    s[1][1] := Zero(fld);
    s[d][d] := Zero(fld);
    s[1][d] := alpha;
    s[d][1] := alpha^(-q);

    t := IdentityMat( d, fld );
    t[1][d] := alpha;

    delta := IdentityMat( d, fld );
    delta[1][1] := w^(q+1);
    delta[d][d] := w^((-(q+1)));

    v := 0 * IdentityMat( d, fld );
    if (IsEvenInt(d)) then
        v[d/2][1] := One(fld);
        v{[1..(d/2)-1]}{[2..d/2]} := IdentityMat((d/2)-1,fld);
        v[d/2+1][d] := One(fld);
        v{[(d/2)+2..d]}{[(d/2)+1..d-1]} := IdentityMat((d/2)-1,fld);
    else
        v[(d-1)/2][1] := One(fld);
        v{[1..((d-1)/2)-1]}{[2..(d-1)/2]} := IdentityMat(((d-1)/2)-1,fld);
        v[((d+1)/2)+1][d] := One(fld);
        v[(d+1)/2][(d+1)/2] := One(fld);
        v{[((d+1)/2)+2..d]}{[((d+1)/2)+1..d-1]} := IdentityMat(((d-1)/2)-1,fld);
    fi;

    u := IdentityMat( d, fld );;
    J := [[Zero(fld),One(fld)],[One(fld),Zero(fld)]];
    u{[1,2]}{[1,2]} := J;
    u{[d-1,d]}{[d-1,d]} := J;

    x := IdentityMat( d, fld );;
    if (IsEvenInt(d)) then
        x[1][2] := One(fld);
        x[d-1][d] := -One(fld);
    else
        x[(d+1)/2][1] := One(fld) * -1;
        x[d][1] := One(fld)* -2^(-1);
        x[d][(d+1)/2] := One(fld);
    fi;

    y := IdentityMat( d, fld );;
    if (IsEvenInt(d)) then
        y[1][1] := w;
        y[2][2] := w^(-1);
        y[d-1][d-1] := w^q;
        y[d][d] := w^(-q);
    else
        y[1][1] := w^(-q);
        y[d][d] := w;
        y[(d+1)/2][(d+1)/2] := w^(q-1);
    fi;


    upper := [];
    lower := [];
    backdiagonal := [];
    for i in [0..ext-1] do
        ele := IdentityMat(d,f);
        ele[1,2] := Z(p,ext)^i;
        ele[d-1,d] := -1*(Z(p,ext)^i)^phi;
        Add(upper,ele);
        ele := IdentityMat(d,f);
        ele[2,1] := Z(p,ext)^i;
        ele[d,d-1] := -1*(Z(p,ext)^i)^phi;
        Add(lower,ele);
    od;

    for i in [0..(ext/2)-1] do
        ele := IdentityMat(d,f);
        ele[1,d] := alpha^(-q)*(w^(q+1))^i;
        Add(backdiagonal,ele);
    od;


    res := rec( s := s, t := t, delta := delta, u := u, x := x, y := y, v := v,
                One := IdentityMat(d,f), one := One(f), alpha := alpha,
                upper := upper, lower := lower, backdiagonal := backdiagonal);
    res.all := Concatenation( res.upper, res.lower, res.backdiagonal, [res.v], [res.u], [res.s], [res.delta], [res.x], [res.y],[res.t] );
    return res;

end;