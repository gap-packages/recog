#############################################################################
##
##  This file is part of recog, a package for the GAP computer algebra system
##  which provides a collection of methods for the constructive recognition
##  of groups.
##
##  This files's authors include Daniel Rademacher.
##
##  Copyright of recog belongs to its developers whose names are too numerous
##  to list here. Please refer to the COPYRIGHT file for details.
##
##  SPDX-License-Identifier: GPL-3.0-or-later
##
#############################################################################



#############################################################################
#############################################################################
######## Main function for orthogonal groups ################################
#############################################################################
#############################################################################



RECOG.FindStdGens_Orthogonal := function(sld)

    return RECOG.FindStdGens_Orthogonal2(sld,DimensionOfMatrixGroup(sld));

end;



RECOG.FindStdGens_Orthogonal2 := function(sld,IsoDim)

# Group generated by input must be isomorphic Sp(IsoDim,q)

# gens of sld must be gens for Sp(d,q) in its natural rep with memory
# This function calls RECOG.SLn_constructsl2 and then extends
# the basis to a basis of the full row space and calls
# RECOG.SLn_UpStep often enough. Finally it returns an slp such
# that the Sp(d,q) standard generators with respect to this basis are
# expressed by the slp in terms of the original generators of sld.
local  V,b,bas,basi,basit,d,data,ext,fakegens,id,nu,nu2,p,q,resl2,sl2,sp4gens,bigcorrection,
        sl2gensf,sl2genss,omega6stdf,slp,slpsl2std,slptosl2,st,std,stdgens,i,ex,f,form,smallomega6,basechange,myslp,omega6gens,omega6,WrongForm,correctForm1,correctForm2;

    # Some setup:
    f := FieldOfMatrixGroup(sld);
    p := Characteristic(f);
    q := Size(f);
    ext := DegreeOverPrimeField(f);
    d := DimensionOfMatrixGroup(sld);
    form := RECOG.SymmetricBilinearForm(sld);
    if not(IsObjWithMemory(GeneratorsOfGroup(sld)[1])) then
        sld := GroupWithMemory(sld);
    fi;

    # First find an Sp2 with the space it acts on;
    Info(InfoRecog,2,"Finding an Omega4...");
    Info(InfoRecog,2,"-----");
    Info(InfoRecog,2,"Start of the GoingDown Algorithm.");
    data := RECOG.SOn_constructso2(sld,d,q,form);
    if data = fail then
        return TemporaryFailure;
    fi;
    Info(InfoRecog,2,"The GoingDown Algorithm was successful.");
    Info(InfoRecog,2,"-----");

    if IsEvenInt(q) then
        smallomega6 := RECOG.ExtractSmallerGroup(GeneratorsOfGroup(data[1]),IdentityMat(20,GF(q)),8);
        WrongForm := PreservedSesquilinearForms(smallomega6[1])[1];
        correctForm1 := BaseChangeToCanonical(WrongForm);
        correctForm2 := BaseChangeToCanonical(PreservedSesquilinearForms(Omega(1,8,q))[1]);
        omega6 := smallomega6[1]^(correctForm1^(-1)*correctForm2);
        bigcorrection := IdentityMat(d,GF(q));
        bigcorrection{[1..8]}{[1..8]} := (correctForm2)^(-1)*correctForm1;
        basechange := bigcorrection*data[2];
        omega6gens := GeneratorsOfGroup(omega6);
        omega6 := RECOG.LiftGroup(GeneratorsOfGroup(omega6),8,q,d)[2];
        Error("here");
    else
        smallomega6 := RECOG.ExtractSmallerGroup(GeneratorsOfGroup(data[1]),IdentityMat(20,GF(q)),6);
        Info(InfoRecog,2,"Start of constructive recognition of Omega(6,q)");
        i := 1;
        omega6gens := fail;
        while i < 10 and omega6gens = fail do
            #if not(IsEvenInt(q)) then
            #    sp4gens := RECOG.FindStdGensSp4(smallsp4[1],d,q);
            #else
                WrongForm := PreservedSesquilinearForms(smallomega6[1])[1];
                correctForm1 := BaseChangeToCanonical(WrongForm);
                correctForm2 := BaseChangeToCanonical(PreservedSesquilinearForms(Omega(1,6,q))[1]);
                omega6 := smallomega6[1]^(correctForm1^(-1)*correctForm2);
                bigcorrection := IdentityMat(d,GF(q));
                bigcorrection{[1..6]}{[1..6]} := (correctForm2)^(-1)*correctForm1;
                basechange := bigcorrection*data[2];
                #stdgens := RECOG.MakeSp_StdGens(p,ext,8,8).all;
                #sp8gens := RECOG.FindStdGensUsingBSGS(sp8,stdgens,false,false);
                #if Size(sp8) <> 197406720 and 174182400 <> Size(sp8) then
                #fi;
                omega6gens := GeneratorsOfGroup(omega6);
            #fi;
            #i := i +1;
        od;
        if omega6gens = fail then
            Info(InfoRecog,2,"-----");
            Info(InfoRecog,2,"Constructive recognition of Sp(4,q) failed. Restart.");
            Info(InfoRecog,2,"-----");
            return TemporaryFailure;
        fi;
        omega6 := RECOG.LiftGroup(GeneratorsOfGroup(omega6),6,q,d)[2];
        Error("here");
    fi;


    # We need an additional check to make sure that we have an omega 6 as our last group



    #basechange := sp4gens[2]*data[2];
    #myslp := CompositionOfStraightLinePrograms(sp4gens[3],myslp);
    #Info(InfoRecog,2,"Constructive recognition of Sp(4,q) was successful.");
    #Info(InfoRecog,2,"-----");

    #fakegens := ListWithIdenticalEntries(Length(GeneratorsOfGroup(sld)), ());
    #fakegens := GeneratorsWithMemory(fakegens);
    #sp4stdf := ResultOfStraightLineProgram(myslp,fakegens);
    #std := rec( f := f, d := d, GoalDim := IsoDim, n := 4, bas := basechange, basi := basechange^(-1),
    #            sld := sld, sldf := fakegens, spnstdf := sp4stdf,
    #            p := p, ext := ext );
    #Info(InfoRecog,2,"Going up to Sp_d again...");
    #Info(InfoRecog,2,"-----");
    #Info(InfoRecog,2,"Start of the GoingUp Algorithm");
    #while std.n < std.GoalDim do
    #    RECOG.Spn_UpStep(std);
    #od;
    #Info(InfoRecog,2,"The GoingUp Algorithm was successful.");
    #Info(InfoRecog,2,"-----");
    #return rec( slpstd := SLPOfElms(std.spnstdf), bas := std.bas, basi := std.basi );
    end;
