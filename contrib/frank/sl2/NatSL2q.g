####################   (c) 2025  Frank LÃ¼beck   ##########################
##  
##  G must be SL(2,q) generated by 2x2 matrices over GF(q).
##  Returns [slps, mat] where slps is list of SLPs in given generators of G 
##  to elements which are conjugate by mat to standard/nice generators: 
##     t, u1, u2 = diag(1/Z(q),Z(q)) [[1,0],[1,1]], [[1,1],[0,1]]
##  
##  We construct elements with the strategy of Section 2. from the article
##    Conder, Leedham-Green, Fast recognition of classical groups
##    over large fields, Groups and Computation III, 2001.
##  and then adjust them to the form described above.
##  
##  Some comments:
##    - To find short SLP to the nice generators we avoid 'PseudoRandom(g)'
##      and instead just start with the trivial element and multiply random
##      generators to it.
##      This should be good enough because in both cases (element xm and twice
##      element cm in the code) almost half of the elements in G are suitable.
##  
##    - The list of SLPs in the result if probably what is needed for the
##      SLPforNiceGens for the RecogNode.
##  
##    - To find for a given element A in G an SLP in the nice generators compute
##       Astd := A^mat and use the function 'SLPinStandardSL2' from the file 
##       "SL2.g".
##    
##    - If q = 2^m with odd m then the computation of the eigenvalues of xm
##      needs the quadratic extension GF(2^(2m)).
##  
##  
##  Example (takes about 15 seconds on my notebook):
##      Size(SL(2,23^15));
##      G:=Group(List([1..4],i->PseudoRandom(SL(2,23^15))));
##      l:=RecogNaturalSL2(G,23^15);
##      nicegens:=List(l[1],a->ResultOfStraightLineProgram(a,GeneratorsOfGroup(G)));
##      List(last, a->a^l[2]);
##  
RecogNaturalSL2 := function(G, q)
  local GM, one, zero, qm1fac, c, m, gens, xm, x, pol, v, z, exp, a, 
        mat, tm, ym, y, ymat, tr, d, cm, r1, r2, r, log, i, trupm, 
        smm, trlowm, F, a2, bas, e, l, emax, tmp;
  GM := GroupWithMemory(G);
  one := One(G.1[1,1]);
  zero := Zero(one);
  
  # find element x of order q-1
  # (a power of x will become the nice generator t later)
  qm1fac := Factors(q-1);
  c := Product(Set(qm1fac));
  m := (q-1)/c;
  gens := GeneratorsOfGroup(GM);
  xm := One(GM);
  repeat 
    #xm := PseudoRandom(GM);
    xm := xm*Random(gens);
    x := StripMemory(xm);
    pol := [one, -x[1,1]-x[2,2], one];
    v := [zero, one];
    v := PowerModCoeffs(v, m, pol);
  until PowerModCoeffs(v, c, pol) = [one] and
            ForAll(qm1fac, p-> PowerModCoeffs(v, c/p, pol) <> [one]);
  # eigenvalues and eigenvectors of x (zeroes of pol)
  # we use Cantor-Zassenhaus
  z := Z(q);
  if q mod 2 = 0 then
    if q mod 3 = 1 then
      exp := (q-1)/3;
    else
      exp := (q^2-1)/3;
      z := Z(q^2);
    fi;
  else
    exp := (q-1)/2;
  fi;
  repeat
    v := [z^Random(0,q-1), one];
    v := PowerModCoeffs(v, exp, pol);
  until Length(v) = 2 and ValuePol(pol, (-v[1]+one)/v[2]) = zero;
  a := (-v[1]+one)/v[2];
  # colums of mat are eigenvectors for a and 1/a (x^mat is diagonal)
  mat := [[-x[1,2], -x[1,2]], [x[1,1]-a, x[1,1]-1/a]];
  if mat[1,1] = zero and mat[2,1] = zero then
    mat[1,1] := x[2,2]-a; mat[2,1] := -x[2,1];
  fi;
  if mat[1,2] = zero and mat[2,2] = zero then
    mat[1,2] := x[2,2]-1/a; mat[2,2] := -x[2,1];
  fi;


  # find conjugate of x with different eigenspaces
  # (almost all conjugates will do)
  tm := One(GM);
  repeat
    tm := tm * Random(gens);
    ym := tm*xm*tm^-1;
    y := StripMemory(ym);
    ymat := y*mat;
  until ymat[1,1]*mat[2,1]-ymat[2,1]*mat[1,1] <> zero and
        ymat[1,2]*mat[2,2]-ymat[2,2]*mat[1,2] <> zero;
  # now y^(tm * mat) = diag(a, a^-1) 
  tr := tm*mat;

  # a-eigenvector of x in new basis
  d := tr^-1 * [mat[1,1],mat[2,1]];
  # can be scaled to [1,d]
  d := d[2]/d[1];
  cm := One(GM);
  repeat
    # look for cm with non-trivial conditions (i <> 0, (q-1)/2)
    repeat 
      cm := cm*Random(gens);
      c := StripMemory(cm)^tr;
      r1 := c[2,1]+d*c[2,2];
      r2 := d^2*c[1,2]+d*c[1,1];
    until r2 <> zero and r1 <> zero and r1 <> r2 and r1 <> -r2;;
    r := r1 / r2;
    log := DLog(a, r, qm1fac);
    i := false;
    if log mod 2 = 0 then
      i := log/2;
    elif q mod 2 = 0 then
      i := (q-1-log)/2;
    fi;
    if IsInt(i) then
      # this will in most cases be a transvection normalized by x
      trupm := Comm(xm, ym^i*cm);
      smm := trupm^mat;
      if smm[1,2] = zero then
        i := false;
      else
        # rescale first column of mat such that trupm^mat = [[1,1],[0,1]]
        mat[1,1] := mat[1,1]*smm[1,2];
        mat[2,1] := mat[2,1]*smm[1,2];
        tr := tm*mat;
      fi;
    fi;
  until IsInt(i);

  # same for the other eigenvector of x:
  # 1/a-eigenvector of x in new basis
  d := tr^-1 * [mat[1,2],mat[2,2]];
  # can be scaled to [1,d]
  d := d[2]/d[1];
  cm := One(GM);
  repeat
    # look for cm with non-trivial conditions (i <> 0, (q-1)/2)
    repeat 
      cm := cm*Random(gens);
      c := StripMemory(cm)^tr;
      r1 := c[2,1]+d*c[2,2];
      r2 := d^2*c[1,2]+d*c[1,1];
    until r2 <> zero and r1 <> zero and r1 <> r2 and r1 <> -r2;;
    r := r1 / r2;
    log := DLog(a, r, qm1fac);
    i := false;
    if log mod 2 = 0 then
      i := log/2;
    elif q mod 2 = 0 then
      i := (q-1-log)/2;
    fi;
    if IsInt(i) then
      # in most cases a transvection which becomes conjugated by mat
      # lower triangular (here it is more difficult to rescale such 
      # that the conjugate matrix is [[1,0],[1,1]]).
      trlowm := Comm(xm, ym^i*cm);
      smm := trlowm^mat;
      if smm[2,1] = zero then
        i := false;
      fi;
    fi;
  until IsInt(i);

  # adjust lower left entry of trlowm^mat to one
  # (we use F_p linear algebra in F_q to find the nice element
  # of products of trlowm^(x^i) for some small i)
  if smm[2,1] <> one then
    F := GF(q);
    a2 := a^2;
    bas := [smm[2,1]];
    e := DegreeOverPrimeField(F);
    for i in [1..e-1] do
      Add(bas, bas[i]*a2);
    od;
    bas := Basis(F, bas);
    l := List(Coefficients(bas, one), IntFFE);
    emax := e;
    while l[emax] = 0 do
      emax := emax-1;
    od;
    tmp := trlowm;
    if l[1] = 0 then
      trlowm := One(GM);
    else
      trlowm := tmp^l[1];
    fi;
    for i in [2..emax] do
      tmp := tmp^xm;
      if l[i] <> 0 then
        trlowm := trlowm*tmp^l[i];
      fi;
    od;
  fi;

  # finally power x to change a to 1/Z(q)
  if a <> 1/Z(q) then
    log := DLog(a, 1/Z(q), qm1fac);
    xm := xm^log;
  fi;

  # return SLPs of elements mapped by mat to 
  # diag(1/Z(q),Z(q))[[1,0],[1,1]], [[1,1],[0,1]],
  # and mat
  return [List([xm, trlowm, trupm], SLPOfElm), mat];
end;

